## C++第26 课：进阶 C++14 新特性


### 一、课程目标 1

* 了解 C++14 的发展背景和主要目标
* 掌握 C++14 相比 C++11 新增的语言特性
* 通过代码示例，学习新特性的使用方法和应用场景

### 二、C++14 简介 2


C++14 是 C++11 的一个小版本更新，主要目标是修复 C++11 中的一些缺陷并进行一些小的改进。它于 2014 年 8 月发布，进一步提升了 C++ 的易用性和效率。

**C++14 主要改进方向：**

* 简化代码编写
* 提升性能和效率
* 增强语言表达能力

### 三、新特性详解 20

#### 3.1  二进制字面量 1

在 C++14 中，可以使用 `0b` 或 `0B` 前缀来表示二进制字面量。

**代码示例:**

```cpp
#include <iostream>

int main() {
  int binaryValue = 0b1101;  // 等价于十进制的 13
  std::cout << binaryValue << std::endl; 
  return 0;
}
```

#### 3.2  数字分隔符 1

可以使用单引号 `'` 作为数字分隔符，提高代码可读性。

**代码示例:**

```cpp
#include <iostream>

int main() {
  long long largeNumber = 1'000'000'000;
  std::cout << largeNumber << std::endl;
  return 0;
}
```

#### 3.3  泛型 Lambda 表达式 3

C++14 允许 Lambda 表达式的参数类型使用 `auto` 关键字，实现泛型 Lambda 表达式。

**代码示例:**

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main() {
  std::vector<int> numbers = {1, 2, 3, 4, 5};
  
  // 使用泛型 Lambda 表达式将每个元素乘以 2
  std::transform(numbers.begin(), numbers.end(), numbers.begin(), 
                 [](auto& n) { return n * 2; });
  
  for (auto n : numbers) {
    std::cout << n << " ";
  }
  std::cout << std::endl;
  return 0;
}
```


#### 3.4  Lambda 捕获表达式中的初始化 2

C++14 允许在 Lambda 捕获表达式中进行变量初始化。

**代码示例:**

```cpp
#include <iostream>

int main() {
  int x = 10;
  
  // 在捕获表达式中初始化变量 y
  auto lambda = [y = x * 2]() {
    std::cout << y << std::endl;
  };
  
  lambda();  // 输出 20
  return 0;
}
```

#### 3.5  变量模板 2

C++14 引入了变量模板，可以定义具有泛型类型的变量。

**代码示例:**

```cpp
#include <iostream>

template<typename T>
constexpr T pi = T(3.1415926535897932385L);

int main() {
  std::cout << pi<float> << std::endl;  // 输出 float 类型的 pi 值
  std::cout << pi<double> << std::endl; // 输出 double 类型的 pi 值
  return 0;
}

```

#### 3.6  constexpr 函数的放宽限制 2

C++14 放宽了 `constexpr` 函数的限制，允许在 `constexpr` 函数中使用更多的语句，例如条件语句、循环语句等。

**代码示例:**

```cpp
#include <iostream>

constexpr int factorial(int n) {
  if (n <= 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

int main() {
  constexpr int result = factorial(5); // 在编译时计算阶乘
  std::cout << result << std::endl;      // 输出 120
  return 0;
}
```

#### 3.7  弃用 `std::gets` 函数 1

由于安全性问题，`std::gets` 函数在 C++14 中被弃用。建议使用更安全的 `std::fgets` 函数替代。

```cpp
#include <iostream>
#include <cstdio> // for gets and fgets

int main() {
  char buffer[10]; 

  std::cout << "请输入一行文字: ";
  std::gets(buffer); // 不安全的函数调用

  std::cout << "您输入的是: " << buffer << std::endl;

  return 0;
}
```



#### 3.8  `[[deprecated]]` 属性 2

C++14 引入了 `[[deprecated]]` 属性，可以用来标记已弃用的函数、类或变量，编译器会发出警告信息。

**代码示例:**

```cpp
#include <iostream>

[[deprecated("Use newFunction instead")]]
void oldFunction() {
  std::cout << "This function is deprecated." << std::endl;
}

void newFunction() {
  std::cout << "This is the new function." << std::endl;
}

int main() {
  oldFunction(); // 编译器会发出警告信息
  newFunction(); 
  return 0;
}
```

## 作业：

编写一个程序，使用泛型 Lambda 表达式对一个 vector 进行排序。

参考实现如下：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

template <typename T>
void sortVector(std::vector<T>& vec) {
  std::sort(vec.begin(), vec.end(), [](const auto& a, const auto& b) {
    return a < b; // 升序排序
  });
}

int main() {
  std::vector<int> intVec = {5, 2, 8, 1, 9, 4};
  std::vector<double> doubleVec = {3.14, 2.71, 1.61, 4.66, 0.99};
  std::vector<std::string> stringVec = {"apple", "banana", "orange", "grape"};

  sortVector(intVec);
  sortVector(doubleVec);
  sortVector(stringVec);

  std::cout << "排序后的 int vector: ";
  for (const auto& num : intVec) {
    std::cout << num << " ";
  }
  std::cout << std::endl;

  std::cout << "排序后的 double vector: ";
  for (const auto& num : doubleVec) {
    std::cout << num << " ";
  }
  std::cout << std::endl;

  std::cout << "排序后的 string vector: ";
  for (const auto& str : stringVec) {
    std::cout << str << " ";
  }
  std::cout << std::endl;

  return 0;
}
```

