作业：

sum, product

arr[i], *(arr+i)

[] => *(arr + i), 性能上没有任何差异
[] 是语言为我们的提供的支持，方便我们书写，非常明确，arr[i]

---------------------------------------------------
'\0', ""

int arr[2][3];

int (*parr)[3] = arr; // 零基础的，Python

int arr1[3];

int* fuctionA(int* px) {
	return nullptr;
}

---------------------------------------------------
you - moduleA,
mate - moduleB, Leader, arch

---------------------------------------------------

递归调用：
1.发生了对自己的调用，A->B->C, A -> ..-> A(递归)

f(n) = n * f(n-1)

f(5) = 5 * f(4) = 5 * 4 * f(3) = 5 * 4 * 3 * 2 * 1 * 1

递归的优点：
1. 描述比较符合直觉，比较形象，同样的逻辑用递归来描述就比较直接，形象

int factorial(int n) {
	int product = 1;
	for (auto i = n; i > 0; i--) {
		product *= i;
	}
}

缺点：
	如果不小心，边界条件设置不好，有可能就产生stack overflow

-------------------------------------------------------
20字节的内存，通过 Python 程序来申请 引子

char* p = new char[20];

-------------------------------------------------------

直接用就行了，Python解释器来给你维护

GC, 对性能产生影响


def fetchMemory(n):
	return [0..n]

n, int arr[n]

void func() {
	int a;
	int b;
	int* p = new int;

	return;
}

函数的局部变量在栈上面，局部变量就是在函数体里面定义的变量

栈是不需要程序员管理的
堆上的是需要程序员管理的，你申请你释放
---------------------------------------------

struct Action {
		
};

passByValue 

void process(const Action& raction) {
	
}

