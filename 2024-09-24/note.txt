vscode中task的配置：
task.json:
	step1:
		type: "bash"
	step2:
	step3:

1. ssh jump-server -> 开发者 home-directory, checkout source tree (vi/emacs/nano, gdb)
2. vscode jump-server -> 开发者 home-directory, checkout source tree
3. gitlab/P4 -> local clion, push CVS, CICD
4. clion remote 卡

-------------------------------------------------------------------------------------

性能优化相关的，二进制扩展来优化程序性能。

算法工程师 -> model -> C/C++ rerwite all the code of python. 二进制扩展的形式来做

Python主体 + C/C++ 二进制扩展

1. 完全重写工作量太大
2. 重写也可能要花费很大的代价来实现完全实现相同的前后处理
3. 不需要（我说你现在给我跑步，时速达到 1m/s就满足要求，你觉得你还有必要跑 5m/s)

工程上一个重要原则：不要提早优化，2-8 原则

研发人员给出一套算法，可能他自己都没有做好，迫于压力先给出“表面”能工作的版本，这个时候工程化的团队也开妈做工程化的准备，
他们可能随时会修改 Python 代码，可能随时会放弃，(所谓的敏捷)，要去找Python代码里的“瓶颈”之处，C/C++重写 Python 里
面比较吃算力的部分。

--------------------------------------------------------------------
嵌入式程序员，Cuda 使用的是 C语言, 自己的编译器，编译的出来的代码跑在自己的芯片上面, JS


--------------------------------------------------------------------

ctypes

pybind11


--------------------------------------------------------------------

C的 ABI 是一个标准，一个事实上的标准，所有系统，所有的语言，所有环境都会支持 C 的 ABI

但是 C++的 ABI 不稳定，不同的编译器，不同的操作系统，不同的环境都可能不一样，同一个编译器
的不同版本也可能不一样。

POC 阶段就是一个字快，找热点，C/C++ 做扩展，全面落地的时候，数量上来了，才会使用 native

--------------------------------------------------------------------

你的程序里面如果是 C 程序，就用.c的扩展名
如果是 C++程序员，就用.cpp

gcc 当看到.cpp的时候，它内部使用的是 C++的一套东西，但是因为你是用 GCC 来调用而不是 G++，所以它会少了一东西
    当看到.c 的时候，它就明确知道这是 C 程序，会用 C 的一套工具来操作

.cpp => g++
.c   => gcc 